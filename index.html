<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Virtual Jewelry Try-On</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        #canvas-container { 
            position: relative; 
            width: 100vw; 
            height: 100vh; 
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* LOCKED LAYOUT: Elements positioned by JS for 1:1 alignment */
        #input-video {
            position: absolute;
            transform: scaleX(-1);
            display: block;
            /* Reset constraints, JS controls size */
            max-width: none; max-height: none; width: auto; height: auto;
        }

        #output-canvas { 
            position: absolute;
            pointer-events: none;
            transform: scaleX(-1);
            /* Canvas size also managed by JS */
        }
        
        /* --- MINIMIZED UI OVERLAY --- */
        #ui-layer {
            position: absolute; top: 12px; left: 12px; z-index: 10;
            background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(4px);
            padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.15);
            color: white; width: 130px; /* Fixed small width */
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2);
        }

        @media (max-width: 600px) {
            #ui-layer {
                top: 12px; left: 12px; bottom: auto; right: auto;
            }
        }

        .toggle-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .toggle-label { font-size: 0.65rem; font-weight: 500; color: #d1d5db; }
        
        /* Loader */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 50; display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
        }
        .spinner {
            border: 3px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 3px solid #fbbf24;
            width: 30px; height: 30px; animation: spin 1s linear infinite; margin-bottom: 12px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Start Button */
        #start-btn {
            display: none; margin-top: 16px; padding: 8px 16px;
            background-color: #fbbf24; color: black; font-weight: bold;
            border-radius: 6px; cursor: pointer; font-size: 0.8rem;
        }

        .status-pill {
            display: inline-block; padding: 1px 5px; border-radius: 4px;
            background: rgba(16, 185, 129, 0.2); color: #6ee7b7;
            font-size: 0.45rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em;
            margin-bottom: 6px;
        }
    </style>

    <!-- Import Three.js and MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p id="status-text" class="text-gray-400 text-xs">Initializing...</p>
        <button id="start-btn" onclick="startCameraManual()">Start Camera</button>
        <div id="error-msg" class="text-red-500 mt-4 px-4 text-xs hidden"></div>
    </div>

    <!-- Minimized UI -->
    <div id="ui-layer">
        <h1 class="text-[10px] font-bold mb-1 text-amber-400 tracking-wider">MCsak TRY-ON</h1>
        <div class="status-pill">Ready</div>
        
        <div class="toggle-item">
            <span class="toggle-label">Earrings</span>
            <input type="checkbox" id="toggle-earring" checked class="accent-amber-500 w-3 h-3 cursor-pointer">
        </div>

        <div class="toggle-item">
            <span class="toggle-label">Necklace</span>
            <input type="checkbox" id="toggle-necklace" checked class="accent-amber-500 w-3 h-3 cursor-pointer">
        </div>

        <div class="toggle-item">
            <span class="toggle-label">Ring</span>
            <input type="checkbox" id="toggle-ring" checked class="accent-amber-500 w-3 h-3 cursor-pointer">
        </div>
        
        <div class="mt-2 pt-1 border-t border-gray-700 text-[7px] text-gray-500 leading-tight">
            <p>MCsak AR Solutions</p>
        </div>
    </div>

    <div id="canvas-container">
        <video id="input-video" playsinline muted autoplay></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const config = { earring: true, necklace: true, ring: true };
        const SMOOTHING = 0.5;
        let currentEyeDist = 0; 
        
        const FACE_OVAL_INDICES = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 
            148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];

        // DOM Elements
        const container = document.getElementById('canvas-container');
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const loader = document.getElementById('loader');
        const statusText = document.getElementById('status-text');
        const startBtn = document.getElementById('start-btn');
        const errorMsg = document.getElementById('error-msg');
        
        // --- PRE-CHECK ---
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            statusText.innerText = "Camera API Unavailable";
            errorMsg.innerHTML = "Use HTTPS or localhost.";
            errorMsg.classList.remove('hidden');
            document.querySelector('.spinner').style.display = 'none';
            throw new Error("Camera API not found");
        }

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.sortObjects = true;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xfffcdd, 1.2);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);
        const spotLight = new THREE.SpotLight(0xffa95c, 2);
        spotLight.position.set(-5, 0, 5);
        scene.add(spotLight);

        const goldMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.2, emissive: 0x442200, emissiveIntensity: 0.1 });
        const gemMaterial = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.05, transmission: 0.9, thickness: 1.0, ior: 2.4 });
        const maskMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, colorWrite: false });

        // --- Models ---
        // Face Mask
        const maskGeometry = new THREE.BufferGeometry();
        const maskVertices = new Float32Array((FACE_OVAL_INDICES.length + 1) * 3);
        maskGeometry.setAttribute('position', new THREE.BufferAttribute(maskVertices, 3));
        const maskIndices = [];
        const centerIdx = 0;
        for (let i = 0; i < FACE_OVAL_INDICES.length; i++) {
            const current = i + 1;
            const next = (i + 1) % FACE_OVAL_INDICES.length + 1;
            maskIndices.push(centerIdx, current, next);
        }
        maskGeometry.setIndex(maskIndices);
        const faceMask = new THREE.Mesh(maskGeometry, maskMaterial);
        faceMask.renderOrder = -1;
        faceMask.matrixAutoUpdate = false; 
        scene.add(faceMask);

        // Earrings
        const leftEarringGroup = new THREE.Group();
        const stud = new THREE.Mesh(new THREE.OctahedronGeometry(0.015), gemMaterial);
        const barHeight = 0.05;
        const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.002, 0.002, barHeight, 8), goldMaterial);
        bar.position.y = -(barHeight / 2) - 0.005; 
        const bigDrop = new THREE.Mesh(new THREE.SphereGeometry(0.015, 32, 32), goldMaterial);
        bigDrop.position.y = -(barHeight) - 0.01; 
        leftEarringGroup.add(stud, bar, bigDrop);
        leftEarringGroup.visible = false;
        scene.add(leftEarringGroup);
        const rightEarringGroup = leftEarringGroup.clone();
        scene.add(rightEarringGroup);

        // Necklace
        const necklaceGroup = new THREE.Group();
        const chainGeo = new THREE.TorusGeometry(0.18, 0.006, 16, 60, Math.PI); 
        const chain = new THREE.Mesh(chainGeo, goldMaterial);
        chain.rotation.z = Math.PI; 
        const pendantGeo = new THREE.OctahedronGeometry(0.035);
        const pendant = new THREE.Mesh(pendantGeo, gemMaterial);
        pendant.position.y = -0.18;
        necklaceGroup.add(chain, pendant);
        necklaceGroup.visible = false;
        scene.add(necklaceGroup);

        // Ring
        const ringGroup = new THREE.Group();
        const ringMeshContainer = new THREE.Group(); 
        const band = new THREE.Mesh(new THREE.TorusGeometry(0.035, 0.005, 16, 50), goldMaterial);
        band.rotation.x = Math.PI / 2;
        const mount = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.005, 0.01, 8), goldMaterial);
        mount.position.z = 0.039; mount.rotation.x = Math.PI / 2;
        const stone = new THREE.Mesh(new THREE.OctahedronGeometry(0.018), gemMaterial);
        stone.position.z = 0.046; stone.rotation.x = Math.PI / 4; stone.rotation.z = Math.PI / 4;
        ringMeshContainer.add(band, mount, stone);
        const fingerMask = new THREE.Mesh(new THREE.CylinderGeometry(0.032, 0.032, 0.2, 32), maskMaterial);
        ringGroup.add(fingerMask);
        ringGroup.add(ringMeshContainer);
        ringGroup.visible = false;
        scene.add(ringGroup);


        // --- LOCKED LAYOUT ENGINE (Manual Alignment) ---
        function updateLayout() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const vw = videoElement.videoWidth || 1280;
            const vh = videoElement.videoHeight || 720;
            const videoAspect = vw / vh;
            const windowAspect = w / h;
            
            let renderW, renderH;
            if (windowAspect > videoAspect) {
                renderW = w; renderH = w / videoAspect;
            } else {
                renderH = h; renderW = h * videoAspect;
            }
            
            const left = (w - renderW) / 2;
            const top = (h - renderH) / 2;
            
            videoElement.style.width = `${renderW}px`;
            videoElement.style.height = `${renderH}px`;
            videoElement.style.left = `${left}px`;
            videoElement.style.top = `${top}px`;
            videoElement.style.objectFit = 'fill'; 
            
            canvasElement.style.width = `${renderW}px`;
            canvasElement.style.height = `${renderH}px`;
            canvasElement.style.left = `${left}px`;
            canvasElement.style.top = `${top}px`;
            
            renderer.setSize(renderW, renderH);
            
            const aspect = renderW / renderH;
            camera.left = -aspect; camera.right = aspect;
            camera.top = 1; camera.bottom = -1;
            camera.updateProjectionMatrix();
        }

        function mapCoord(x, y) {
            const aspect = camera.right; 
            const nx = (x - 0.5) * 2 * aspect;
            const ny = -(y - 0.5) * 2;
            return new THREE.Vector3(nx, ny, 0);
        }
        
        function getZScale() { return camera.right * 2.5; }
        function getDistanceWorld(p1, p2) {
             const v1 = mapCoord(p1.x, p1.y);
             const v2 = mapCoord(p2.x, p2.y);
             return v1.distanceTo(v2);
        }
        function smoothTransform(object, targetPos, targetRotZ, targetScale, alpha) {
            object.position.lerp(targetPos, alpha);
            object.rotation.z = object.rotation.z * (1 - alpha) + targetRotZ * alpha;
            const currentS = object.scale.x;
            const newS = currentS * (1 - alpha) + targetScale * alpha;
            object.scale.set(newS, newS, newS);
        }
        
        // --- MediaPipe Setup ---
        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        faceMesh.onResults(onFaceResults);

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onHandResults);

        function onFaceResults(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
                leftEarringGroup.visible = false; rightEarringGroup.visible = false; necklaceGroup.visible = false;
                faceMask.position.set(0,0,1000); currentEyeDist = 0; return;
            }
            const landmarks = results.multiFaceLandmarks[0];
            const zScale = getZScale();
            const noseTip = landmarks[1];
            
            // Mask Update
            const centerPos = mapCoord(noseTip.x, noseTip.y);
            const positions = faceMask.geometry.attributes.position.array;
            positions[0] = centerPos.x; positions[1] = centerPos.y; positions[2] = -noseTip.z * zScale;
            for (let i = 0; i < FACE_OVAL_INDICES.length; i++) {
                const lm = landmarks[FACE_OVAL_INDICES[i]];
                const pos = mapCoord(lm.x, lm.y);
                const idx = (i + 1) * 3;
                positions[idx] = pos.x; positions[idx+1] = pos.y; positions[idx+2] = -lm.z * zScale;
            }
            faceMask.geometry.attributes.position.needsUpdate = true;
            faceMask.geometry.computeBoundingSphere();

            // Logic
            const eyeDistWorld = getDistanceWorld(landmarks[33], landmarks[263]);
            currentEyeDist = eyeDistWorld; 
            const faceHeightWorld = getDistanceWorld(landmarks[10], landmarks[152]);
            const dLeft = Math.abs(noseTip.x - landmarks[234].x);
            const dRight = Math.abs(noseTip.x - landmarks[454].x);
            const faceWidthRaw = dLeft + dRight;
            const showLeftEar = (dLeft / faceWidthRaw) > 0.25;
            const showRightEar = (dRight / faceWidthRaw) > 0.25;

            // Earrings
            if (config.earring) {
                const targetScale = eyeDistWorld * 5.0;
                const leftLobe = landmarks[132]; 
                const rightLobe = landmarks[361];
                const centerFace = mapCoord(landmarks[168].x, landmarks[168].y); 
                const autoPush = eyeDistWorld * 0.04; 

                if (showLeftEar) {
                    leftEarringGroup.visible = true;
                    const posL = mapCoord(leftLobe.x, leftLobe.y);
                    const pushVecL = new THREE.Vector3().subVectors(posL, centerFace).setZ(0).normalize();
                    posL.add(pushVecL.multiplyScalar(autoPush));
                    posL.z = (-leftLobe.z * zScale); 
                    smoothTransform(leftEarringGroup, posL, 0, targetScale, SMOOTHING);
                } else leftEarringGroup.visible = false;

                if (showRightEar) {
                    rightEarringGroup.visible = true;
                    const posR = mapCoord(rightLobe.x, rightLobe.y);
                    const pushVecR = new THREE.Vector3().subVectors(posR, centerFace).setZ(0).normalize();
                    posR.add(pushVecR.multiplyScalar(autoPush));
                    posR.z = (-rightLobe.z * zScale);
                    smoothTransform(rightEarringGroup, posR, 0, targetScale, SMOOTHING);
                } else rightEarringGroup.visible = false;
            } else {
                leftEarringGroup.visible = false; rightEarringGroup.visible = false;
            }

            // Necklace
            if (config.necklace) {
                necklaceGroup.visible = true;
                const leftEarTragus = landmarks[234];
                const rightEarTragus = landmarks[454];
                const midEarX = (leftEarTragus.x + rightEarTragus.x) / 2;
                const midEarY = (leftEarTragus.y + rightEarTragus.y) / 2;
                const pos = mapCoord(midEarX, midEarY);
                const neckDrop = faceHeightWorld * 0.7; 
                pos.y -= neckDrop;
                const chin = landmarks[152];
                pos.z = (-chin.z * zScale) - (faceHeightWorld * 0.2); 
                const targetScale = eyeDistWorld * 5.5;
                const leftEye = landmarks[33];
                const rightEye = landmarks[263];
                let headRoll = -Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x); 
                smoothTransform(necklaceGroup, pos, headRoll * 0.05, targetScale, SMOOTHING);
            } else necklaceGroup.visible = false;
        }

        function onHandResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                ringGroup.visible = false; return;
            }
            const landmarks = results.multiHandLandmarks[0];
            if (config.ring) {
                ringGroup.visible = true;
                const mcp = landmarks[13]; const pip = landmarks[14]; 
                const midX = (mcp.x + pip.x) / 2; const midY = (mcp.y + pip.y) / 2;
                const pos = mapCoord(midX, midY);
                const posMCP = mapCoord(mcp.x, mcp.y); const posPIP = mapCoord(pip.x, pip.y);
                const angle = Math.atan2(posPIP.y - posMCP.y, posPIP.x - posMCP.x);
                const targetRotZ = angle - (Math.PI / 2);
                const handLenWorld = getDistanceWorld(landmarks[0], landmarks[9]);
                const targetScale = handLenWorld * 4.5;
                if (currentEyeDist > 0) {
                    const zScale = getZScale();
                    pos.z = (handLenWorld - (currentEyeDist * 0.85)) * zScale * 6.0;
                } else pos.z = 0;
                smoothTransform(ringGroup, pos, targetRotZ, targetScale, SMOOTHING);
            } else ringGroup.visible = false;
        }

        // --- MANUAL CAMERA & INIT ---
        let isCameraRunning = false;
        window.startCameraManual = async function() {
            statusText.innerText = "Initializing...";
            const constraints = { video: { facingMode: 'user' } };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                statusText.innerText = "Loading AI...";
                
                videoElement.oncanplay = () => {
                    videoElement.play().then(() => {
                        startBtn.style.display = 'none';
                        loader.style.display = 'none';
                        isCameraRunning = true;
                        updateLayout();
                        requestAnimationFrame(processFrame);
                    }).catch(err => {
                        console.error("Play blocked", err);
                        statusText.innerText = "Tap to Start";
                        startBtn.style.display = 'block';
                    });
                };
            } catch (err) {
                console.error("Camera Init Failed", err);
                statusText.innerText = "Error";
                errorMsg.innerText = err.message;
                errorMsg.classList.remove('hidden');
            }
        };

        async function processFrame() {
            if (!isCameraRunning) return;
            if (videoElement.readyState >= 2) {
                await faceMesh.send({image: videoElement});
                await hands.send({image: videoElement});
                renderer.render(scene, camera);
            }
            requestAnimationFrame(processFrame);
        }

        startCameraManual();

        // UI & Events
        document.getElementById('toggle-earring').addEventListener('change', (e) => config.earring = e.target.checked);
        document.getElementById('toggle-necklace').addEventListener('change', (e) => config.necklace = e.target.checked);
        document.getElementById('toggle-ring').addEventListener('change', (e) => config.ring = e.target.checked);
        
        window.addEventListener('resize', updateLayout);
        window.addEventListener('orientationchange', () => setTimeout(updateLayout, 100));
        videoElement.addEventListener('loadedmetadata', updateLayout);
        setInterval(() => {
            if (videoElement.videoWidth > 0 && Math.abs(videoElement.clientWidth - canvasElement.clientWidth) > 2) {
                updateLayout();
            }
        }, 1000);

    </script>
</body>
</html>
