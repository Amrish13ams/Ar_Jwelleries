<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Virtual Jewelry Try-On</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        #canvas-container { 
            position: relative; 
            width: 100vw; 
            height: 100vh; 
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Elements are positioned absolutely by JS for perfect alignment */
        #input-video, #output-canvas { 
            position: absolute;
            top: 0; left: 0;
            transform-origin: top left;
        }

        #input-video {
            transform: scaleX(-1); /* Mirror video */
            display: block;
            /* Default to fill, JS will size the element to match aspect ratio */
            width: 100%;
            height: 100%;
            object-fit: fill; 
        }

        #output-canvas { 
            pointer-events: none;
            transform: scaleX(-1); /* Mirror 3D context to match */
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 16px; left: 16px; z-index: 10;
            background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(6px);
            padding: 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15);
            color: white; width: 150px; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
        }

        @media (max-width: 600px) {
            #ui-layer {
                width: auto;
                left: 16px;
                right: auto;
                bottom: 20px;
                top: auto;
            }
        }

        .toggle-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .toggle-label { font-size: 0.7rem; font-weight: 500; color: #d1d5db; }
        
        /* Loader & Error Overlay */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 50; display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 4px solid #fbbf24;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 16px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Start Button (Hidden by default) */
        #start-btn {
            display: none;
            margin-top: 20px;
            padding: 12px 24px;
            background-color: #fbbf24;
            color: black;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
        }

        .status-pill {
            display: inline-block; padding: 2px 6px; border-radius: 8px;
            background: rgba(16, 185, 129, 0.2); color: #6ee7b7;
            font-size: 0.55rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em;
            margin-bottom: 8px;
        }
    </style>

    <!-- Import Three.js and MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p id="status-text" class="text-gray-300">Requesting Camera Access...</p>
        <button id="start-btn" onclick="startCameraManual()">Start Camera</button>
        <div id="error-msg" class="text-red-500 mt-4 px-4 max-w-sm hidden"></div>
    </div>

    <div id="ui-layer">
        <h1 class="text-xs font-bold mb-1 text-amber-400 tracking-wider">LUXE TRY-ON</h1>
        <div class="status-pill">Active</div>
        
        <div class="toggle-item">
            <span class="toggle-label">Earrings</span>
            <input type="checkbox" id="toggle-earring" checked class="accent-amber-500 w-3 h-3 cursor-pointer">
        </div>

        <div class="toggle-item">
            <span class="toggle-label">Necklace</span>
            <input type="checkbox" id="toggle-necklace" checked class="accent-amber-500 w-3 h-3 cursor-pointer">
        </div>

        <div class="toggle-item">
            <span class="toggle-label">Ring</span>
            <input type="checkbox" id="toggle-ring" checked class="accent-amber-500 w-3 h-3 cursor-pointer">
        </div>
        
        <div class="mt-2 pt-2 border-t border-gray-700 text-[9px] text-gray-500">
            <p>1:1 Physical Alignment.</p>
            <p>Fixed for Mobile.</p>
        </div>
    </div>

    <div id="canvas-container">
        <!-- Muted/Autoplay/Playsinline are mandatory for mobile video -->
        <video id="input-video" playsinline muted autoplay></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const config = {
            earring: true,
            necklace: true,
            ring: true
        };
        
        const SMOOTHING = 0.5;
        let currentEyeDist = 0; 
        
        const FACE_OVAL_INDICES = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 
            148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];

        // DOM Elements
        const container = document.getElementById('canvas-container');
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const loader = document.getElementById('loader');
        const statusText = document.getElementById('status-text');
        const startBtn = document.getElementById('start-btn');
        const errorMsg = document.getElementById('error-msg');
        
        // --- ERROR HANDLING & INIT ---
        window.onerror = function(message, source, lineno, colno, error) {
            statusText.innerText = "Error Detected";
            errorMsg.innerText = message;
            errorMsg.classList.remove('hidden');
        };

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            statusText.innerText = "Camera Not Supported";
            errorMsg.innerHTML = "<b>Use HTTPS</b> or localhost.<br>Standard http:// blocks camera.";
            errorMsg.classList.remove('hidden');
            document.querySelector('.spinner').style.display = 'none';
            throw new Error("Camera API not found");
        }

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        
        // Camera setup - Updated in updateLayout
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.sortObjects = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xfffcdd, 1.2);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);
        const spotLight = new THREE.SpotLight(0xffa95c, 2);
        spotLight.position.set(-5, 0, 5);
        scene.add(spotLight);

        // Materials
        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xffd700, metalness: 0.9, roughness: 0.2, emissive: 0x442200, emissiveIntensity: 0.1
        });
        const gemMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, metalness: 0.1, roughness: 0.05, transmission: 0.9, thickness: 1.0, ior: 2.4
        });
        const maskMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, colorWrite: false });

        // --- Models ---
        // 0. Face Occluder
        const maskGeometry = new THREE.BufferGeometry();
        const maskVertices = new Float32Array((FACE_OVAL_INDICES.length + 1) * 3);
        maskGeometry.setAttribute('position', new THREE.BufferAttribute(maskVertices, 3));
        const maskIndices = [];
        const centerIdx = 0;
        for (let i = 0; i < FACE_OVAL_INDICES.length; i++) {
            const current = i + 1;
            const next = (i + 1) % FACE_OVAL_INDICES.length + 1;
            maskIndices.push(centerIdx, current, next);
        }
        maskGeometry.setIndex(maskIndices);
        const faceMask = new THREE.Mesh(maskGeometry, maskMaterial);
        faceMask.renderOrder = -1;
        faceMask.matrixAutoUpdate = false; 
        scene.add(faceMask);

        // 1. Earring Group (Left) - Linear Drop
        const leftEarringGroup = new THREE.Group();
        const stud = new THREE.Mesh(new THREE.OctahedronGeometry(0.015), gemMaterial);
        const barHeight = 0.05;
        const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.002, 0.002, barHeight, 8), goldMaterial);
        bar.position.y = -(barHeight / 2) - 0.005; 
        const bigDrop = new THREE.Mesh(new THREE.SphereGeometry(0.015, 32, 32), goldMaterial);
        bigDrop.position.y = -(barHeight) - 0.01; 
        leftEarringGroup.add(stud, bar, bigDrop);
        leftEarringGroup.visible = false;
        scene.add(leftEarringGroup);

        const rightEarringGroup = leftEarringGroup.clone();
        scene.add(rightEarringGroup);

        // 2. Necklace Group
        const necklaceGroup = new THREE.Group();
        const chainGeo = new THREE.TorusGeometry(0.18, 0.006, 16, 60, Math.PI); 
        const chain = new THREE.Mesh(chainGeo, goldMaterial);
        chain.rotation.z = Math.PI; 
        const pendantGeo = new THREE.OctahedronGeometry(0.035);
        const pendant = new THREE.Mesh(pendantGeo, gemMaterial);
        pendant.position.y = -0.18;
        necklaceGroup.add(chain, pendant);
        necklaceGroup.visible = false;
        scene.add(necklaceGroup);

        // 3. Ring Group
        const ringGroup = new THREE.Group();
        const ringMeshContainer = new THREE.Group(); 
        const band = new THREE.Mesh(new THREE.TorusGeometry(0.035, 0.005, 16, 50), goldMaterial);
        band.rotation.x = Math.PI / 2;
        const mount = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.005, 0.01, 8), goldMaterial);
        mount.position.z = 0.039; mount.rotation.x = Math.PI / 2;
        const stone = new THREE.Mesh(new THREE.OctahedronGeometry(0.018), gemMaterial);
        stone.position.z = 0.046; stone.rotation.x = Math.PI / 4; stone.rotation.z = Math.PI / 4;
        ringMeshContainer.add(band, mount, stone);
        const fingerMask = new THREE.Mesh(new THREE.CylinderGeometry(0.032, 0.032, 0.2, 32), maskMaterial);
        ringGroup.add(fingerMask);
        ringGroup.add(ringMeshContainer);
        ringGroup.visible = false;
        scene.add(ringGroup);


        // --- LOCKED LAYOUT ENGINE (Manual Alignment) ---
        
        function updateLayout() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            // Get actual source dimensions (fallback if not loaded)
            const vw = videoElement.videoWidth || 1280;
            const vh = videoElement.videoHeight || 720;
            const videoAspect = vw / vh;
            const windowAspect = w / h;
            
            // Calculate Cover Dimensions (What sizes would fill the screen?)
            let renderW, renderH;
            
            if (windowAspect > videoAspect) {
                // Screen is wider: Video fits width, crops height (Top/Bottom)
                renderW = w;
                renderH = w / videoAspect;
            } else {
                // Screen is taller: Video fits height, crops width (Left/Right)
                renderH = h;
                renderW = h * videoAspect;
            }
            
            // Calculate Centering Offsets (Negative values to pull content center)
            const left = (w - renderW) / 2;
            const top = (h - renderH) / 2;
            
            // 1. Force Video Element Size & Position
            videoElement.style.width = `${renderW}px`;
            videoElement.style.height = `${renderH}px`;
            videoElement.style.left = `${left}px`;
            videoElement.style.top = `${top}px`;
            videoElement.style.objectFit = 'fill'; // Ensure exact pixel match
            
            // 2. Force Canvas Element Size & Position (Identical to Video)
            canvasElement.style.width = `${renderW}px`;
            canvasElement.style.height = `${renderH}px`;
            canvasElement.style.left = `${left}px`;
            canvasElement.style.top = `${top}px`;
            
            // 3. Resize WebGL Buffer (Matches Render Size)
            renderer.setSize(renderW, renderH);
            
            // 4. Update Camera Frustum to match Aspect Ratio
            // Ortho Width = 2 * aspect, Height = 2
            const aspect = renderW / renderH;
            camera.left = -aspect;
            camera.right = aspect;
            camera.top = 1;
            camera.bottom = -1;
            camera.updateProjectionMatrix();
        }

        // Simple Mapping: Since Canvas == Video 1:1, we map 0..1 to Ortho bounds directly
        function mapCoord(x, y) {
            const aspect = camera.right; // stored aspect from updateLayout
            
            // Map x (0..1) -> (-aspect .. +aspect)
            const nx = (x - 0.5) * 2 * aspect;
            // Map y (0..1) -> (1 .. -1) (Flipped)
            const ny = -(y - 0.5) * 2;
            
            return new THREE.Vector3(nx, ny, 0);
        }
        
        function getZScale() {
            // Scale Z depth based on world width
            return camera.right * 2.5; 
        }

        function getDistanceWorld(p1, p2) {
             const v1 = mapCoord(p1.x, p1.y);
             const v2 = mapCoord(p2.x, p2.y);
             return v1.distanceTo(v2);
        }

        function smoothTransform(object, targetPos, targetRotZ, targetScale, alpha) {
            object.position.lerp(targetPos, alpha);
            object.rotation.z = object.rotation.z * (1 - alpha) + targetRotZ * alpha;
            const currentS = object.scale.x;
            const newS = currentS * (1 - alpha) + targetScale * alpha;
            object.scale.set(newS, newS, newS);
        }
        
        // --- MediaPipe Setup ---
        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({ 
            maxNumFaces: 1, 
            refineLandmarks: false, 
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5 
        });
        faceMesh.onResults(onFaceResults);

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ 
            maxNumHands: 1, 
            modelComplexity: 0,
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5 
        });
        hands.onResults(onHandResults);


        // --- Processing Logic ---

        function onFaceResults(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
                leftEarringGroup.visible = false;
                rightEarringGroup.visible = false;
                necklaceGroup.visible = false;
                faceMask.position.set(0,0,1000);
                currentEyeDist = 0; 
                return;
            }

            const landmarks = results.multiFaceLandmarks[0];
            const zScale = getZScale();

            const noseTip = landmarks[1];
            const dLeft = Math.abs(noseTip.x - landmarks[234].x);
            const dRight = Math.abs(noseTip.x - landmarks[454].x);
            const faceWidthRaw = dLeft + dRight;
            const VISIBILITY_THRESHOLD = 0.25; 
            const showLeftEar = (dLeft / faceWidthRaw) > VISIBILITY_THRESHOLD;
            const showRightEar = (dRight / faceWidthRaw) > VISIBILITY_THRESHOLD;

            // 1. Update Mask
            const centerPos = mapCoord(noseTip.x, noseTip.y);
            const positions = faceMask.geometry.attributes.position.array;
            positions[0] = centerPos.x; positions[1] = centerPos.y; positions[2] = -noseTip.z * zScale;
            for (let i = 0; i < FACE_OVAL_INDICES.length; i++) {
                const lm = landmarks[FACE_OVAL_INDICES[i]];
                const pos = mapCoord(lm.x, lm.y);
                const idx = (i + 1) * 3;
                positions[idx] = pos.x; positions[idx+1] = pos.y; positions[idx+2] = -lm.z * zScale;
            }
            faceMask.geometry.attributes.position.needsUpdate = true;
            faceMask.geometry.computeBoundingSphere();

            // 2. Metrics
            const eyeDistWorld = getDistanceWorld(landmarks[33], landmarks[263]);
            currentEyeDist = eyeDistWorld; 
            const faceHeightWorld = getDistanceWorld(landmarks[10], landmarks[152]);
            
            // --- Earrings ---
            if (config.earring) {
                const targetScale = eyeDistWorld * 5.0;
                const gravityRot = 0; 
                const leftLobe = landmarks[132]; 
                const rightLobe = landmarks[361];
                const centerFace = mapCoord(landmarks[168].x, landmarks[168].y); 
                
                const autoPush = eyeDistWorld * 0.04; 
                const autoDrop = 0;

                if (showLeftEar) {
                    leftEarringGroup.visible = true;
                    const posL = mapCoord(leftLobe.x, leftLobe.y);
                    const pushVecL = new THREE.Vector3().subVectors(posL, centerFace).setZ(0).normalize();
                    posL.add(pushVecL.multiplyScalar(autoPush));
                    posL.y -= autoDrop;
                    posL.z = (-leftLobe.z * zScale); 
                    smoothTransform(leftEarringGroup, posL, gravityRot, targetScale, SMOOTHING);
                } else leftEarringGroup.visible = false;

                if (showRightEar) {
                    rightEarringGroup.visible = true;
                    const posR = mapCoord(rightLobe.x, rightLobe.y);
                    const pushVecR = new THREE.Vector3().subVectors(posR, centerFace).setZ(0).normalize();
                    posR.add(pushVecR.multiplyScalar(autoPush));
                    posR.y -= autoDrop;
                    posR.z = (-rightLobe.z * zScale);
                    smoothTransform(rightEarringGroup, posR, gravityRot, targetScale, SMOOTHING);
                } else rightEarringGroup.visible = false;
            } else {
                leftEarringGroup.visible = false;
                rightEarringGroup.visible = false;
            }

            // --- Necklace ---
            if (config.necklace) {
                necklaceGroup.visible = true;
                const leftEarTragus = landmarks[234];
                const rightEarTragus = landmarks[454];
                const midEarX = (leftEarTragus.x + rightEarTragus.x) / 2;
                const midEarY = (leftEarTragus.y + rightEarTragus.y) / 2;
                const pos = mapCoord(midEarX, midEarY);
                
                const neckDrop = faceHeightWorld * 0.7; 
                pos.y -= neckDrop;
                
                const chin = landmarks[152];
                pos.z = (-chin.z * zScale) - (faceHeightWorld * 0.2); 
                
                const targetScale = eyeDistWorld * 5.5;
                
                const leftEye = landmarks[33];
                const rightEye = landmarks[263];
                let headRoll = -Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x); 
                const shoulderStableRot = headRoll * 0.05;

                smoothTransform(necklaceGroup, pos, shoulderStableRot, targetScale, SMOOTHING);
            } else {
                necklaceGroup.visible = false;
            }
        }

        function onHandResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                ringGroup.visible = false;
                return;
            }
            const landmarks = results.multiHandLandmarks[0];
            if (config.ring) {
                ringGroup.visible = true;
                const mcp = landmarks[13]; 
                const pip = landmarks[14]; 
                const midX = (mcp.x + pip.x) / 2;
                const midY = (mcp.y + pip.y) / 2;
                const pos = mapCoord(midX, midY);

                const posMCP = mapCoord(mcp.x, mcp.y);
                const posPIP = mapCoord(pip.x, pip.y);
                const angle = Math.atan2(posPIP.y - posMCP.y, posPIP.x - posMCP.x);
                const targetRotZ = angle - (Math.PI / 2);

                const handLenWorld = getDistanceWorld(landmarks[0], landmarks[9]);
                const targetScale = handLenWorld * 4.5;
                
                if (currentEyeDist > 0) {
                    const zScale = getZScale();
                    const zShift = (handLenWorld - (currentEyeDist * 0.85)) * zScale * 6.0;
                    pos.z = zShift;
                } else pos.z = 0;

                smoothTransform(ringGroup, pos, targetRotZ, targetScale, SMOOTHING);
            } else ringGroup.visible = false;
        }

        // --- MANUAL CAMERA START (Fix for Black Screen) ---

        const isMobile = window.innerWidth < window.innerHeight;
        let isCameraRunning = false;

        window.startCameraManual = async function() {
            statusText.innerText = "Requesting Stream...";
            
            const constraints = {
                video: {
                    facingMode: 'user',
                    width: { ideal: isMobile ? 720 : 1280 },
                    height: { ideal: isMobile ? 1280 : 720 }
                }
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                statusText.innerText = "Stream Loaded. Playing...";
                
                videoElement.onloadedmetadata = () => {
                    videoElement.play().then(() => {
                        console.log("Video playing");
                        startBtn.style.display = 'none';
                        loader.style.display = 'none';
                        isCameraRunning = true;
                        updateLayout();
                        requestAnimationFrame(processFrame);
                    }).catch(err => {
                        console.error("Play failed", err);
                        statusText.innerText = "Tap button to start";
                        startBtn.style.display = 'block';
                    });
                };
            } catch (err) {
                console.error("GUM failed", err);
                statusText.innerText = "Access Denied / Error";
                errorMsg.innerText = err.message;
                errorMsg.classList.remove('hidden');
            }
        };

        // Main Loop
        async function processFrame() {
            if (!isCameraRunning) return;
            
            if (videoElement.readyState >= 2) { // HAVE_CURRENT_DATA
                await faceMesh.send({image: videoElement});
                await hands.send({image: videoElement});
                renderer.render(scene, camera);
            }
            requestAnimationFrame(processFrame);
        }

        // Auto-start try
        startCameraManual();


        // --- UI & Events ---
        document.getElementById('toggle-earring').addEventListener('change', (e) => config.earring = e.target.checked);
        document.getElementById('toggle-necklace').addEventListener('change', (e) => config.necklace = e.target.checked);
        document.getElementById('toggle-ring').addEventListener('change', (e) => config.ring = e.target.checked);
        
        window.addEventListener('resize', updateLayout);
        window.addEventListener('orientationchange', () => setTimeout(updateLayout, 100));
        videoElement.addEventListener('loadedmetadata', updateLayout);
        
        // Periodic check to fix layout shifts
        setInterval(() => {
            if (videoElement.videoWidth > 0 && Math.abs(videoElement.clientWidth - canvasElement.clientWidth) > 2) {
                updateLayout();
            }
        }, 1000);

    </script>
</body>
</html>
