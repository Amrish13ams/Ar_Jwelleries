<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Virtual Jewelry Try-On</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        #canvas-container { 
            position: relative; 
            width: 100vw; 
            height: 100vh; 
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Video: Contain shows the full sensor (Zoomed Out / Fit Screen) */
        #input-video { 
            position: absolute;
            width: 100%; 
            height: 100%; 
            object-fit: contain; 
            transform: scaleX(-1); 
            opacity: 1; 
        }
        
        /* Canvas: Absolute on top, matches container size */
        #output-canvas { 
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1); 
            pointer-events: none; 
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(8px);
            padding: 20px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.15);
            color: white; width: 260px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
        }

        /* Mobile UI positioning */
        @media (max-width: 600px) {
            #ui-layer {
                width: calc(100% - 40px);
                bottom: 30px;
                top: auto;
                left: 20px;
            }
        }

        .toggle-item {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;
        }
        .toggle-label { font-size: 0.95rem; font-weight: 500; color: #e5e7eb; }
        
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; z-index: 20; text-align: center; width: 100%; pointer-events: none;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 4px solid #fbbf24;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 10px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .status-pill {
            display: inline-block; padding: 4px 8px; border-radius: 12px;
            background: rgba(16, 185, 129, 0.2); color: #6ee7b7;
            font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em;
            margin-bottom: 16px;
        }
    </style>

    <!-- Import Three.js and MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p>Calibrating...</p>
    </div>

    <div id="ui-layer">
        <h1 class="text-xl font-bold mb-2 text-amber-400 tracking-wider">LUXE TRY-ON</h1>
        <div class="status-pill">Fit Screen Mode</div>
        
        <div class="toggle-item">
            <span class="toggle-label">Earrings</span>
            <input type="checkbox" id="toggle-earring" checked class="accent-amber-500 w-5 h-5 cursor-pointer">
        </div>

        <div class="toggle-item">
            <span class="toggle-label">Necklace</span>
            <input type="checkbox" id="toggle-necklace" checked class="accent-amber-500 w-5 h-5 cursor-pointer">
        </div>

        <div class="toggle-item">
            <span class="toggle-label">Ring</span>
            <input type="checkbox" id="toggle-ring" checked class="accent-amber-500 w-5 h-5 cursor-pointer">
        </div>
        
        <div class="mt-4 pt-4 border-t border-gray-700 text-xs text-gray-400">
            <p>Full camera view.</p>
            <p>No cropping.</p>
        </div>
    </div>

    <div id="canvas-container">
        <video id="input-video" playsinline></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const config = {
            earring: true,
            necklace: true,
            ring: true
        };
        
        // Smoothing Factor
        const SMOOTHING = 0.5;

        let currentEyeDist = 0; 
        
        const FACE_OVAL_INDICES = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 
            148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];

        // DOM Elements
        const container = document.getElementById('canvas-container');
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const loader = document.getElementById('loader');
        
        // --- ERROR HANDLING ---
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            const isFile = window.location.protocol === 'file:';
            let errorMsg = "Camera API is not available.";
            if (isFile) errorMsg = "<b>Error:</b> File opened locally. Use a local server (localhost).";
            else errorMsg = "<b>Error:</b> HTTPS required for camera access.";

            loader.style.pointerEvents = "auto"; 
            loader.innerHTML = `
                <div class="text-red-400 p-6 bg-gray-900 border border-red-800 rounded-xl max-w-sm mx-auto shadow-2xl">
                    <h3 class="font-bold text-lg mb-2">⚠️ Camera Blocked</h3>
                    <p class="text-sm text-gray-300">${errorMsg}</p>
                </div>`;
            throw new Error("Camera API not found");
        }

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true, antialias: true });
        // PERFORMANCE FIX: Cap pixel ratio to 2 to avoid lag on high-res mobiles
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.sortObjects = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xfffcdd, 1.2);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);
        const spotLight = new THREE.SpotLight(0xffa95c, 2);
        spotLight.position.set(-5, 0, 5);
        scene.add(spotLight);

        // Materials
        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xffd700, metalness: 0.9, roughness: 0.2, emissive: 0x442200, emissiveIntensity: 0.1
        });
        const gemMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, metalness: 0.1, roughness: 0.05, transmission: 0.9, thickness: 1.0, ior: 2.4
        });
        const maskMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, colorWrite: false });

        // --- Models ---
        
        // 0. Face Occluder
        const maskGeometry = new THREE.BufferGeometry();
        const maskVertices = new Float32Array((FACE_OVAL_INDICES.length + 1) * 3);
        maskGeometry.setAttribute('position', new THREE.BufferAttribute(maskVertices, 3));
        const maskIndices = [];
        const centerIdx = 0;
        for (let i = 0; i < FACE_OVAL_INDICES.length; i++) {
            const current = i + 1;
            const next = (i + 1) % FACE_OVAL_INDICES.length + 1;
            maskIndices.push(centerIdx, current, next);
        }
        maskGeometry.setIndex(maskIndices);
        const faceMask = new THREE.Mesh(maskGeometry, maskMaterial);
        faceMask.renderOrder = -1;
        faceMask.matrixAutoUpdate = false; 
        scene.add(faceMask);

        // 1. Earring Group (Left) - Linear Drop
        const leftEarringGroup = new THREE.Group();
        const stud = new THREE.Mesh(new THREE.OctahedronGeometry(0.015), gemMaterial);
        const barHeight = 0.05;
        const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.002, 0.002, barHeight, 8), goldMaterial);
        bar.position.y = -(barHeight / 2) - 0.005; 
        const bigDrop = new THREE.Mesh(new THREE.SphereGeometry(0.015, 32, 32), goldMaterial);
        bigDrop.position.y = -(barHeight) - 0.01; 
        leftEarringGroup.add(stud, bar, bigDrop);
        leftEarringGroup.visible = false;
        scene.add(leftEarringGroup);

        const rightEarringGroup = leftEarringGroup.clone();
        scene.add(rightEarringGroup);

        // 2. Necklace Group
        const necklaceGroup = new THREE.Group();
        const chainGeo = new THREE.TorusGeometry(0.18, 0.006, 16, 60, Math.PI); 
        const chain = new THREE.Mesh(chainGeo, goldMaterial);
        chain.rotation.z = Math.PI; 
        const pendantGeo = new THREE.OctahedronGeometry(0.035);
        const pendant = new THREE.Mesh(pendantGeo, gemMaterial);
        pendant.position.y = -0.18;
        necklaceGroup.add(chain, pendant);
        necklaceGroup.visible = false;
        scene.add(necklaceGroup);

        // 3. Ring Group
        const ringGroup = new THREE.Group();
        const ringMeshContainer = new THREE.Group(); 
        const band = new THREE.Mesh(new THREE.TorusGeometry(0.035, 0.005, 16, 50), goldMaterial);
        band.rotation.x = Math.PI / 2;
        const mount = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.005, 0.01, 8), goldMaterial);
        mount.position.z = 0.039; mount.rotation.x = Math.PI / 2;
        const stone = new THREE.Mesh(new THREE.OctahedronGeometry(0.018), gemMaterial);
        stone.position.z = 0.046; stone.rotation.x = Math.PI / 4; stone.rotation.z = Math.PI / 4;
        ringMeshContainer.add(band, mount, stone);
        const fingerMask = new THREE.Mesh(new THREE.CylinderGeometry(0.032, 0.032, 0.2, 32), maskMaterial);
        ringGroup.add(fingerMask);
        ringGroup.add(ringMeshContainer);
        ringGroup.visible = false;
        scene.add(ringGroup);


        // --- ROBUST MAPPING LOGIC (Fit Screen / Contain) ---
        // Accurately maps 3D objects to the video pixels, accounting for black bars.
        
        function mapCoord(x, y) {
            const vw = videoElement.videoWidth || 1280;
            const vh = videoElement.videoHeight || 720;
            if (!vw || !vh) return new THREE.Vector3(0,0,0);

            const videoAspect = vw / vh;
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            const screenAspect = screenW / screenH;

            // Calculate dimensions of the video on screen (CONTAIN mode)
            let renderW, renderH;
            let startX = 0, startY = 0;

            if (screenAspect > videoAspect) {
                // Screen is wider: Video fits height, bars on sides (Pillarbox)
                renderH = screenH;
                renderW = screenH * videoAspect;
                startX = (screenW - renderW) / 2;
            } else {
                // Screen is taller: Video fits width, bars on top/bottom (Letterbox)
                renderW = screenW;
                renderH = screenW / videoAspect;
                startY = (screenH - renderH) / 2;
            }

            // Convert Normalized (0..1) to Screen Pixels (including offsets)
            const px = startX + (x * renderW);
            const py = startY + (y * renderH);

            // Convert Screen Pixels to 3D World Units
            // Ortho Camera maps: Width = 2*aspect, Height = 2
            const worldH = 2;
            const worldW = worldH * screenAspect;

            // Map 0..screenW -> -worldW/2 .. +worldW/2
            const nx = (px / screenW) * worldW - (worldW / 2);
            // Map 0..screenH -> +worldH/2 .. -worldH/2 (Y is flipped in 3D)
            const ny = (worldH / 2) - (py / screenH) * worldH;

            return new THREE.Vector3(nx, ny, 0);
        }
        
        function getZScale() {
            // Scale Z depth based on world scale
            return 2.5; 
        }

        function getDistanceWorld(p1, p2) {
             const v1 = mapCoord(p1.x, p1.y);
             const v2 = mapCoord(p2.x, p2.y);
             return v1.distanceTo(v2);
        }

        function smoothTransform(object, targetPos, targetRotZ, targetScale, alpha) {
            object.position.lerp(targetPos, alpha);
            object.rotation.z = object.rotation.z * (1 - alpha) + targetRotZ * alpha;
            const currentS = object.scale.x;
            const newS = currentS * (1 - alpha) + targetScale * alpha;
            object.scale.set(newS, newS, newS);
        }
        
        // --- MediaPipe Setup ---
        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({ 
            maxNumFaces: 1, 
            refineLandmarks: false, // PERFORMANCE: Disable iris tracking
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5 
        });
        faceMesh.onResults(onFaceResults);

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ 
            maxNumHands: 1, 
            modelComplexity: 0, // PERFORMANCE: Lite model
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5 
        });
        hands.onResults(onHandResults);


        // --- Processing Logic ---

        function onFaceResults(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
                leftEarringGroup.visible = false;
                rightEarringGroup.visible = false;
                necklaceGroup.visible = false;
                faceMask.position.set(0,0,1000);
                currentEyeDist = 0; 
                return;
            }

            const landmarks = results.multiFaceLandmarks[0];
            const zScale = getZScale();

            const noseTip = landmarks[1];
            const dLeft = Math.abs(noseTip.x - landmarks[234].x);
            const dRight = Math.abs(noseTip.x - landmarks[454].x);
            const faceWidthRaw = dLeft + dRight;
            const VISIBILITY_THRESHOLD = 0.25; 
            const showLeftEar = (dLeft / faceWidthRaw) > VISIBILITY_THRESHOLD;
            const showRightEar = (dRight / faceWidthRaw) > VISIBILITY_THRESHOLD;

            // 1. Update Mask
            const centerPos = mapCoord(noseTip.x, noseTip.y);
            const positions = faceMask.geometry.attributes.position.array;
            positions[0] = centerPos.x; positions[1] = centerPos.y; positions[2] = -noseTip.z * zScale;
            for (let i = 0; i < FACE_OVAL_INDICES.length; i++) {
                const lm = landmarks[FACE_OVAL_INDICES[i]];
                const pos = mapCoord(lm.x, lm.y);
                const idx = (i + 1) * 3;
                positions[idx] = pos.x; positions[idx+1] = pos.y; positions[idx+2] = -lm.z * zScale;
            }
            faceMask.geometry.attributes.position.needsUpdate = true;
            faceMask.geometry.computeBoundingSphere();

            // 2. Metrics
            const eyeDistWorld = getDistanceWorld(landmarks[33], landmarks[263]);
            currentEyeDist = eyeDistWorld; 
            const faceHeightWorld = getDistanceWorld(landmarks[10], landmarks[152]);
            
            // --- Earrings ---
            if (config.earring) {
                // Reduced size multiplier to 4.5 for better fit in Contain mode
                const targetScale = eyeDistWorld * 4.5;
                // Using precise anatomical lobe tips (132/361)
                const leftLobe = landmarks[132]; 
                const rightLobe = landmarks[361];

                if (showLeftEar) {
                    leftEarringGroup.visible = true;
                    const posL = mapCoord(leftLobe.x, leftLobe.y);
                    posL.z = (-leftLobe.z * zScale); 
                    smoothTransform(leftEarringGroup, posL, 0, targetScale, SMOOTHING);
                } else leftEarringGroup.visible = false;

                if (showRightEar) {
                    rightEarringGroup.visible = true;
                    const posR = mapCoord(rightLobe.x, rightLobe.y);
                    posR.z = (-rightLobe.z * zScale);
                    smoothTransform(rightEarringGroup, posR, 0, targetScale, SMOOTHING);
                } else rightEarringGroup.visible = false;
            } else {
                leftEarringGroup.visible = false;
                rightEarringGroup.visible = false;
            }

            // --- Necklace ---
            if (config.necklace) {
                necklaceGroup.visible = true;
                const anchor = landmarks[168]; 
                const pos = mapCoord(anchor.x, anchor.y);
                
                const neckDrop = faceHeightWorld * 0.9; 
                pos.y -= neckDrop;
                
                const chin = landmarks[152];
                pos.z = (-chin.z * zScale) - (faceHeightWorld * 0.2); 
                
                const targetScale = eyeDistWorld * 5.5;
                
                const leftEye = landmarks[33];
                const rightEye = landmarks[263];
                let headRoll = -Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x); 
                const shoulderStableRot = headRoll * 0.05; 

                smoothTransform(necklaceGroup, pos, shoulderStableRot, targetScale, SMOOTHING);
            } else {
                necklaceGroup.visible = false;
            }
        }

        function onHandResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                ringGroup.visible = false;
                return;
            }
            const landmarks = results.multiHandLandmarks[0];
            if (config.ring) {
                ringGroup.visible = true;
                const mcp = landmarks[13]; 
                const pip = landmarks[14]; 
                const midX = (mcp.x + pip.x) / 2;
                const midY = (mcp.y + pip.y) / 2;
                const pos = mapCoord(midX, midY);

                const posMCP = mapCoord(mcp.x, mcp.y);
                const posPIP = mapCoord(pip.x, pip.y);
                const angle = Math.atan2(posPIP.y - posMCP.y, posPIP.x - posMCP.x);
                const targetRotZ = angle - (Math.PI / 2);

                const handLenWorld = getDistanceWorld(landmarks[0], landmarks[9]);
                const targetScale = handLenWorld * 4.5;
                
                if (currentEyeDist > 0) {
                    const zScale = getZScale();
                    const zShift = (handLenWorld - (currentEyeDist * 0.85)) * zScale * 6.0;
                    pos.z = zShift;
                } else pos.z = 0;

                smoothTransform(ringGroup, pos, targetRotZ, targetScale, SMOOTHING);
            } else ringGroup.visible = false;
        }

        // --- Camera & Resizing ---

        function handleResize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            const newAspect = w / h;
            camera.left = -newAspect;
            camera.right = newAspect;
            camera.top = 1;
            camera.bottom = -1;
            camera.updateProjectionMatrix();
            
            renderer.setSize(w, h);
        }

        const isMobile = window.innerWidth < window.innerHeight;
        const cameraConfig = {
            onFrame: async () => {
                await faceMesh.send({image: videoElement});
                await hands.send({image: videoElement});
                renderer.render(scene, camera);
            },
            width: isMobile ? 720 : 1280,
            height: isMobile ? 1280 : 720,
            facingMode: 'user'
        };

        const cameraUtils = new Camera(videoElement, cameraConfig);
        cameraUtils.start().then(() => loader.style.display = 'none');

        document.getElementById('toggle-earring').addEventListener('change', (e) => config.earring = e.target.checked);
        document.getElementById('toggle-necklace').addEventListener('change', (e) => config.necklace = e.target.checked);
        document.getElementById('toggle-ring').addEventListener('change', (e) => config.ring = e.target.checked);
        
        window.addEventListener('resize', handleResize);
        videoElement.addEventListener('loadeddata', handleResize);
        setTimeout(handleResize, 500);

    </script>
</body>
</html>
